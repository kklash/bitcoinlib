package taproot

import (
	"crypto/subtle"
	"errors"
	"io"
	"math/big"

	"github.com/kklash/ekliptic"
)

var (
	// This is a point generated by hashing the secp256k1 generator point's uncompressed DER encoding.
	// It is thus provable that its private key is unknown, because of its transparent generation process.
	deadGeneratorX = new(big.Int).SetBytes([]byte{
		0x50, 0x92, 0x9b, 0x74, 0xc1, 0xa0, 0x49, 0x54, 0xb7, 0x8b, 0x4b, 0x60, 0x35, 0xe9, 0x7a, 0x5e,
		0x07, 0x8a, 0x5a, 0x0f, 0x28, 0xec, 0x96, 0xd5, 0x47, 0xbf, 0xee, 0x9a, 0xce, 0x80, 0x3a, 0xc0,
	})
	deadGeneratorY = new(big.Int).SetBytes([]byte{
		0x31, 0xd3, 0xc6, 0x86, 0x39, 0x73, 0x92, 0x6e, 0x04, 0x9e, 0x63, 0x7c, 0xb1, 0xb5, 0xf4, 0x0a,
		0x36, 0xda, 0xc2, 0x8a, 0xf1, 0x76, 0x69, 0x68, 0xc3, 0x0c, 0x23, 0x13, 0xf3, 0xa3, 0x89, 0x04,
	})
)

var ErrDeadProofInvalid = errors.New("failed to validate proof of dead internal key")

func buildDeadKey(r *big.Int) []byte {
	rGx, rGy := ekliptic.MultiplyBasePoint(r)

	// H + rG
	deadX, _ := ekliptic.AddAffine(
		deadGeneratorX, deadGeneratorY,
		rGx, rGy,
	)
	return deadX.FillBytes(make([]byte, 32))
}

// BuildDeadKey generates a dead public key whose private key is provably unknown
// based on a given proof.
func BuildDeadKey(proof []byte) []byte {
	r := new(big.Int).SetBytes(proof)
	return buildDeadKey(r)
}

// NewDeadKey generates a random dead key whose private key is provably unknown.
// Returns the schnorr-serialized public key and a proof that can be used
// to verify the public key indeed has no private key, using VerifyDeadKey.
func NewDeadKey(random io.Reader) (key, proof []byte, err error) {
	r, err := ekliptic.RandomScalar(random)
	if err != nil {
		return nil, nil, err
	}
	proof = r.FillBytes(make([]byte, 32))
	key = buildDeadKey(r)
	return
}

// VerifyDeadKey verifies the given dead public key was generated using proof.
// Runs in constant time.
//
// If VerifyDeadKey returns nil, the given key is successfully proven to have
// been generated with H + rG, where G is the secp256k1 base point, r is the
// integer form of the proof, and H is a publicly known generator point whose
// coordinates were derived from SHA256(G).
//
// If the proof fails to verify, VerifyDeadKey returns ErrDeadProofInvalid.
func VerifyDeadKey(key, proof []byte) error {
	r := new(big.Int).SetBytes(proof)
	if !ekliptic.IsValidScalar(r) {
		return ErrDeadProofInvalid
	}

	dead := buildDeadKey(r)
	if subtle.ConstantTimeCompare(key, dead) != 1 {
		return ErrDeadProofInvalid
	}
	return nil
}
